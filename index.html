<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>JavaScript &amp; React - Tóm tắt kiến thức </title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
    margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-interactiveBlue { background-color: rgba(35, 131, 226, .07); }
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-translucentGray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }
.select-value-color-pageGlass { background-color: undefined; }
.select-value-color-washGlass { background-color: undefined; }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="66ec731c-d1f3-46d2-a242-1a52abd1b7b9" class="page serif"><header><div class="page-header-icon undefined"><span class="icon">✍🏼</span></div><h1 class="page-title"><strong><strong>JavaScript &amp; React - Tóm tắt kiến thức</strong></strong> </h1><p class="page-description"></p></header><div class="page-body"><h3 id="d2b2c19d-09d5-45e3-948a-c56ee93aeee7" class="">Các khái niệm <strong>JavaScript </strong></h3><p id="f4f2fa7f-c6df-4be2-8d6a-fafd087ac9e9" class=""><strong>1. ES6 (ES2015)</strong></p><ul id="18e78786-1ae3-4aeb-8e26-934a3a5700a0" class="bulleted-list"><li style="list-style-type:disc"><strong>Định nghĩa</strong>: Phiên bản cập nhật lớn nhất của JavaScript, mang đến nhiều tính năng mới và cải tiến.</li></ul><p id="a0e74709-62b2-4bd1-9564-b148fab035fc" class=""><strong>2. Arrow Functions</strong></p><ul id="c4233083-e34f-4d93-82c7-b1e2d72ee704" class="bulleted-list"><li style="list-style-type:disc"><strong>Định nghĩa</strong>: Cách mới và ngắn gọn hơn để viết function.</li></ul><ul id="f81bb058-a040-4e8d-adcd-49cca086398a" class="bulleted-list"><li style="list-style-type:disc"><strong>Ví dụ</strong>: <code><strong>(a, b) =&gt; a + b</strong></code> thay vì <code><strong>function(a, b) { return a + b; }</strong></code>.</li></ul><p id="5e09897d-97a1-4eb5-b59b-5c4cb14fbbcf" class=""><strong>3. Asynchronize in JS</strong></p><ul id="46c80a36-f0a6-4cbc-834a-13a7fe2bccdc" class="bulleted-list"><li style="list-style-type:disc"><strong>Callback</strong>: Hàm truyền như tham số, thực thi sau khi hàm chứa hoàn tất .</li></ul><pre id="fafbc706-dccc-4c77-82dc-852031b81568" class="code"><code>function greeting(name, callback) {
    console.log(`Hello ${name}`);
    callback();
}

function alertFinished() {
    console.log("Greeting is finished!");
}

greeting("John", alertFinished);</code></pre><ul id="a68c727b-7617-454c-86c8-a471738e564a" class="bulleted-list"><li style="list-style-type:disc"><strong>Promise</strong>: Đối tượng đại diện cho sự hoàn thành của một thao tác bất đồng bộ.</li></ul><p id="ba07dd82-e5d1-4466-8fd1-7d37521a72be" class=""><strong>Cách hoạt động</strong>:</p><ol type="1" id="8adb6031-602c-48f7-b409-1914964aaf9e" class="numbered-list" start="1"><li>Một <code><strong>Promise</strong></code> có ba trạng thái: <code><strong>pending</strong></code> (đang chờ), <code><strong>fulfilled</strong></code> (hoàn thành), và <code><strong>rejected</strong></code> (bị từ chối).</li></ol><ol type="1" id="822cb997-13bf-4981-8c31-635ef0a804e3" class="numbered-list" start="2"><li>Khi một <code><strong>Promise</strong></code> được tạo ra, nó ở trạng thái <code><strong>pending</strong></code>.</li></ol><ol type="1" id="3823e5b1-ef5f-46a5-a528-d57ee29b46ce" class="numbered-list" start="3"><li>Khi kết quả được trả về, nó chuyển sang trạng thái <code><strong>fulfilled</strong></code> hoặc <code><strong>rejected</strong></code>.</li></ol><pre id="df95344b-3318-446a-9206-8e89b44a41e8" class="code"><code>const promiseExample = new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
        resolve("Promise is resolved!");
        // Or you could reject("Promise was rejected!");
    }, 1000);
});

promiseExample.then((message) =&gt; {
    console.log(message);  // Output: "Promise is resolved!"
}).catch((error) =&gt; {
    console.log(error);
});</code></pre><ul id="2da82ecb-4ec6-41bf-ac5f-7ba98f15272d" class="bulleted-list"><li style="list-style-type:disc"><strong>async/await</strong>: Làm việc với bất đồng bộ dễ dàng và rõ ràng.</li></ul><p id="8c90bb5d-f3e5-46dd-b227-06e833e794c8" class=""><strong>Cách hoạt động</strong>:</p><ol type="1" id="4b937a0a-7782-493a-81fd-e2b35b9ae070" class="numbered-list" start="1"><li>Từ khóa <code><strong>async</strong></code> trước một function nghĩa là function sẽ trả về một <code><strong>Promise</strong></code>.</li></ol><ol type="1" id="03d6131c-dafc-4377-a9d1-773537a3d3b9" class="numbered-list" start="2"><li>Từ khóa <code><strong>await</strong></code> chỉ có thể được sử dụng trong một function được định nghĩa với <code><strong>async</strong></code>. Nó giúp mã dừng lại và đợi cho đến khi <code><strong>Promise</strong></code> được giải quyết.</li></ol><pre id="35996751-2486-4677-81bf-d0f1993d2271" class="code"><code>const asyncFunction = async () =&gt; {
    const result = await promiseExample;  // waiting for the promise to resolve
    console.log(result);  // Output: "Promise is resolved!"
};

asyncFunction().catch((error) =&gt; {
    console.log(error);
});</code></pre><p id="6f0713e3-ea37-45b9-986a-d7f521fd406f" class=""><strong>4. this &amp; OOP</strong></p><ul id="2219e1b7-f7d6-44bb-bfb1-69ef043466bf" class="bulleted-list"><li style="list-style-type:disc"><strong>this</strong>: Tham chiếu đến đối tượng hiện tại.</li></ul><pre id="50a687ee-792b-4f4b-aff4-7e53d7640222" class="code"><code>const person = {
    name: "John",
    sayHello: function() {
        console.log(`Hello, my name is ${this.name}`);
    }
};

person.sayHello();  // Output: "Hello, my name is John"</code></pre><p id="4fd7a773-b988-4ace-8a14-dc1f43519b31" class="">Tuy nhiên, lưu ý rằng <code><strong>this</strong></code> trong arrow functions không hoạt động theo cùng một cách: qua trung gian </p><pre id="fa7a53cc-5193-4808-bcf5-7e3b8ebb867f" class="code"><code>const personArrow = {
    name: "John",
    sayHello: () =&gt; {
        console.log(`Hello, my name is ${this.name}`);
    }
};

personArrow.sayHello();  // Output: "Hello, my name is undefined"</code></pre><pre id="8229475d-9a40-43b9-ac92-abd6057019a9" class="code"><code>function Person() {
  this.age = 0;

  // Sử dụng arrow function
  setInterval(() =&gt; {
    this.age++;
    console.log(this.age);
  }, 1000);

  // Sử dụng function bình thường
  /* 
  sử dụng một biến (thường là self hoặc that) để giữ ngữ cảnh this ban đầu:
  const self = this;
  setInterval(function() {
    self.age++;
    console.log(self.age);
  }, 1000);
  */
}

const person = new Person();

// khi sử dụng arrow function thì this trỏ thẳng tới object Person 
// khi sử dụng function bình thường thì cần phải gán 1 biến để trỏ tới </code></pre><p id="96ffc089-464e-49e6-9e3b-d8cb2daa5e9d" class="">
</p><ul id="1391e49b-60a5-4369-a1e1-9d7a5f77fab9" class="bulleted-list"><li style="list-style-type:disc"><strong>OOP</strong>: Phương pháp tạo ra đối tượng giống như thực tế.</li></ul><pre id="1a9ab4c4-e1cc-47b9-aa28-66d361deb9bf" class="code"><code>class Animal {
    constructor(name) {
        this.name = name;
    }

    speak() {
        console.log(`${this.name} makes a noise.`);
    }
}

class Dog extends Animal {
    speak() {
        console.log(`${this.name} barks.`);
    }
}

const dog = new Dog('Rex');
dog.speak();  // Output: "Rex barks."

const genericAnimal = new Animal('Animal');
genericAnimal.speak();  // Output: "Animal makes a noise."
</code></pre><p id="b8dcc836-8516-4ba1-a0f5-23911913679e" class=""><strong>5. Basic Syntax</strong></p><p id="d189741a-90af-42c3-853a-be6dd0af666d" class=""><strong>Biến</strong></p><pre id="97710bc7-8d6d-46c7-b714-e97d443b9716" class="code"><code>// ES6 introduces let and const for variable declaration
let variable = "ES6 variable";
const constantVariable = "This value cannot change";</code></pre><p id="47dcc478-9e88-4b44-ba04-dfaf346f0c52" class=""><strong>Các kiểu dữ liệu</strong></p><pre id="823d493a-5629-41ba-bd19-b2ef55ec09b0" class="code"><code>let number = 123;
let string = "Hello, World!";
let boolean = true;
let object = { firstName: "John", lastName: "Doe" };
let array = [1, 2, 3, 4];</code></pre><p id="5e294bad-3a38-4a15-bb73-37dc59e6b043" class=""><strong>Chức năng</strong></p><pre id="c4d8db57-c9b8-441d-9df0-27ac3e0603ec" class="code"><code>function greet(name) {
  return "Hello, " + name + "!";
}</code></pre><p id="0c0a281f-cd04-404c-8151-6a9e78a97807" class=""><strong>Câu lệnh điều kiện</strong></p><pre id="9dbe4156-4739-48ab-9e48-2d315727e575" class="code"><code>const b = 14

if(b &gt; 15 ){
    console.log('oke');
}
else{
    console.log('loi');
}</code></pre><p id="04339d79-13aa-4b8e-abc2-9965fee6ca23" class=""><strong>Vòng lặp</strong></p><pre id="23f67cd9-6015-4027-b46f-0e44cab569d2" class="code"><code>const number =  [1,2,3,4,5,6]
for(let a = 1; a &lt; number.length; a ++)</code></pre><p id="e8133dc3-2d6b-42f7-b23f-467c7a37b2bb" class=""><strong>6. DOM </strong></p><p id="0c5f3bfb-f8df-4970-95eb-2442f138a848" class=""><strong>Truy cập phần tử</strong>:</p><pre id="815e9f47-8ff4-47e2-917c-aa2c290cc450" class="code"><code>document.getElementById('elementId');
document.querySelector('.className');</code></pre><p id="d6947dcf-1d98-472e-8cb2-e01e96a90540" class=""><strong>Thay đổi nội dung</strong>:</p><pre id="0b13fcfb-92b7-4cff-b979-deb91a9023cb" class="code"><code>let rename = document.getElementById('elementId');
rename.innerHTML = 'Stdio'</code></pre><p id="77d4152a-36bc-437e-897e-089ad2fc2b0c" class=""><strong>Thêm/Xóa lớp CSS</strong>:</p><pre id="31a47ad8-0116-48b8-b4bf-e5f9082a20a7" class="code"><code>element.classList.add('new-class');
element.classList.remove('old-class');</code></pre><p id="7eab8a90-13c7-4dce-8ed4-4c8b3dbb2863" class=""><strong>7. BOM (Browser Object Model):</strong></p><p id="e45c2e75-a20f-47da-a573-53c57549d423" class=""><strong>Cửa sổ</strong>:</p><pre id="6328a083-c018-459e-a8c9-716f1283a527" class="code"><code>window.open();  // Mở một cửa sổ mới
window.close(); // Đóng cửa sổ hiện tại
window.innerWidth;  // Chiều rộng của viewport</code></pre><p id="3d400be8-bc03-4ccf-8256-8fe00bd9327b" class=""><strong>Vị trí</strong>:</p><pre id="bbdda127-e892-48f2-a920-663cad2a8f3b" class="code"><code>window.location.href;  // Chuyển về URL hiện tại</code></pre><p id="84868bad-ed1e-475d-956a-3c8bcd8ad393" class=""><strong>Lịch sử</strong>:</p><pre id="adc35167-38b3-4288-b9f1-d825b23817f0" class="code"><code>window.history.back();  // Quay lại trang trước</code></pre><p id="b68d0721-0fa1-43c3-8944-1bc08e696cd9" class=""><strong>Bộ định giờ</strong>:</p><pre id="3cdc171e-9c39-4a8a-a245-44e3c9682b65" class="code"><code>setTimeout(function, milliseconds); 
//setTimeout sẽ chạy hàm chỉ một lần sau một khoảng thời gian đã được xác định (được chỉ định bằng milliseconds).

setInterval(function, milliseconds);
//setInterval sẽ chạy hàm liên tục sau mỗi khoảng thời gian đã được xác định, cho đến khi bạn dừng nó hoặc trang web bị đóng.</code></pre><p id="6c234410-e24c-4fa2-bd81-e5ad1ae11d4d" class=""><strong>8. Column &amp; Grid System:</strong></p><pre id="d5d4edff-7c35-4026-b5c5-8367cd87f141" class="code"><code>&lt;div class="container"&gt;
    &lt;div class="row"&gt;
        &lt;div class="col-md-8"&gt;Column 1&lt;/div&gt;
        &lt;div class="col-md-4"&gt;Column 2&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre><p id="77b98610-6f31-4064-9ccf-b48dedf4faa3" class=""><strong>9. Helper Classes:</strong></p><pre id="e9421417-c6ac-43a8-b0ed-bcb3bc71dbce" class="code"><code>Màu sắc: .text-primary, .bg-danger, ...
Khoảng cách: Padding (p-*) và Margin (m-*) như .mt-3 (margin-top 3 units), .pb-2 (padding-bottom 2 units).
Hiển thị: .d-none (ẩn), .d-block (block display), .d-flex (flexbox display) và nhiều class khác dành cho responsive design.</code></pre><p id="dd966ca7-2ef9-42fd-91d2-68831d562081" class=""><strong>10.  Phương thức call(), Bind(), apply()</strong></p><ul id="ed5c86b5-9db7-4e85-9c0c-111131ad1675" class="bulleted-list"><li style="list-style-type:disc"><strong>Cú pháp</strong>: <code><strong>function.call(thisArg, arg1, arg2, ...)</strong></code></li></ul><ul id="7a38d0a3-93c5-4bd7-bc16-70d87964620e" class="bulleted-list"><li style="list-style-type:disc"><strong>Mô tả</strong>: Phương thức <code><strong>call()</strong></code> gọi một hàm với một giá trị <code><strong>this</strong></code> được chỉ định và các đối số được cung cấp dưới dạng riêng lẻ.</li></ul><ul id="17e6bb4a-6b7d-4d65-844e-43603bb1dbf7" class="bulleted-list"><li style="list-style-type:disc"><strong>Ví dụ</strong>:</li></ul><pre id="c9f42397-ca3e-48c6-8038-7794db0008f8" class="code"><code>function chao(firstName, lastName) {
    console.log(`Xin chào, ${firstName} ${lastName}. Tôi tên là ${this.name}`);
}

const nguoi = { name: 'Alice' };

chao.call(nguoi, 'Bob', 'Smith');  // Kết quả: Xin chào, Bob Smith. Tôi tên là Alice</code></pre><ul id="d191dd04-1175-4fd6-b9b1-87424d30be99" class="bulleted-list"><li style="list-style-type:disc"><strong>Cú pháp</strong>: <code><strong>function.apply(thisArg, [argsArray])</strong></code></li></ul><ul id="1ed04081-c1a6-4cf0-be74-499f44f34cdb" class="bulleted-list"><li style="list-style-type:disc"><strong>Mô tả</strong>: Phương thức <code><strong>apply()</strong></code> giống như <code><strong>call()</strong></code>, nhưng nó nhận một mảng (hoặc đối tượng giống mảng) của đối số, thay vì từng đối số riêng lẻ.</li></ul><ul id="5b6e8f07-2289-441e-aa55-f4d50c09bfe4" class="bulleted-list"><li style="list-style-type:disc"><strong>Ví dụ</strong>:</li></ul><pre id="5903019a-5f62-4465-aeaf-cbc18adf9f17" class="code"><code>function chao(firstName, lastName) {
    console.log(`Xin chào, ${firstName} ${lastName}. Tôi tên là ${this.name}`);
}

const nguoi = { name: 'Alice' };

chao.apply(nguoi, ['Bob', 'Smith']);  // Kết quả: Xin chào, Bob Smith. Tôi tên là Alice</code></pre><ul id="1502df77-7062-4ba5-b691-713e0ea0a222" class="bulleted-list"><li style="list-style-type:disc"><strong>Cú pháp</strong>: <code><strong>function.bind(thisArg, arg1, arg2, ...)</strong></code></li></ul><ul id="faa641ea-3447-4778-9eed-25c871012ab2" class="bulleted-list"><li style="list-style-type:disc"><strong>Mô tả</strong>: Phương thức <code><strong>bind()</strong></code> tạo ra một hàm mới, khi được gọi, từ khóa <code><strong>this</strong></code> của nó được đặt thành giá trị đã cung cấp. Hàm mới cũng có một chuỗi đối số được cung cấp cho phương thức <code><strong>bind()</strong></code>, theo sau là bất kỳ đối số nào được truyền vào hàm mới.</li></ul><ul id="3c35bcd3-f144-42e0-b72a-6762d7674543" class="bulleted-list"><li style="list-style-type:disc"><strong>Ví dụ</strong>:</li></ul><pre id="a7c599e8-c0e0-4286-8ea8-21305905b35b" class="code"><code>function chao(firstName, lastName) {
    console.log(`Xin chào, ${firstName} ${lastName}. Tên tôi là ${this.name}`);
}

const nguoi = { name: 'Alice' };
const chaoDaRangBuoc = chao.bind(nguoi);

chaoDaRangBuoc('Bob', 'Smith');  // Xuất ra: Xin chào, Bob Smith. Tên tôi là Alice</code></pre><h3 id="965d4c17-2fdb-417c-8d43-16c8ba2e8b5f" class=""><strong>Điểm khác biệt chính:</strong></h3><ol type="1" id="6a25d9ab-5224-4a18-b6c9-ff1fac85f330" class="numbered-list" start="1"><li><strong>Thực thi ngay lập tức</strong>: Cả <code><strong>call()</strong></code> và <code><strong>apply()</strong></code> đều thực thi hàm ngay lập tức. Tuy nhiên, <code><strong>bind()</strong></code> trả về một hàm mới với ngữ cảnh và đối số đã xác định, sẵn sàng để được gọi sau này.</li></ol><ol type="1" id="2ed5bcad-2cee-442c-942f-5e8601fc2679" class="numbered-list" start="2"><li><strong>Đối số</strong>:<ul id="c002b01b-581d-40ca-b73c-f064ddd7d0c0" class="bulleted-list"><li style="list-style-type:disc"><code><strong>call()</strong></code>: Nhận đối số <code><strong>this</strong></code> trước, sau đó là danh sách các đối số.</li></ul><ul id="05c1f1dd-bd40-4b7c-8ee7-9e3554e51a71" class="bulleted-list"><li style="list-style-type:disc"><code><strong>apply()</strong></code>: Nhận đối số <code><strong>this</strong></code> trước, sau đó là một mảng đối số.</li></ul><ul id="3dc578cf-e5ed-48cd-a9c4-fdd75a8b875c" class="bulleted-list"><li style="list-style-type:disc"><code><strong>bind()</strong></code>: Giống như <code><strong>call()</strong></code>, nó nhận đối số <code><strong>this</strong></code> trước, sau đó là danh sách các đối số. Nhưng nhớ rằng, nó không thực thi hàm ngay lập tức.</li></ul></li></ol><p id="3935b9a3-7aa8-4035-b500-c8e7cc5fb5b5" class=""><strong>11. JSON</strong></p><p id="cc721c7c-f380-4682-bc17-1fad4b1ce82e" class=""><strong>JSON (JavaScript Object Notation)</strong>:</p><ul id="36176ec2-3558-4aa8-ac3a-1fde20d7fda8" class="bulleted-list"><li style="list-style-type:disc"><strong>Mô tả</strong>: Là một định dạng dữ liệu dễ đọc và viết cho con người, cũng như dễ cho máy tính phân tích và tạo ra. Thường được sử dụng để truyền dữ liệu giữa máy khách và máy chủ.</li></ul><p id="15ffaf09-f928-46f4-83ff-5085a2ee12c7" class=""><strong>JSON's Methods</strong>:</p><p id="81fe67dd-cf4d-4342-9584-95a871c70337" class=""><strong>JSON.stringify()</strong>:</p><ul id="357a6b21-1b3a-4afc-9e10-110c0be206da" class="bulleted-list"><li style="list-style-type:disc"><strong>Mô tả</strong>: Chuyển đổi một giá trị JavaScript thành một chuỗi JSON.</li></ul><ul id="ca4217c5-5a9d-461c-8fab-6ddc1f5f3308" class="bulleted-list"><li style="list-style-type:disc"><strong>Ví dụ</strong>:</li></ul><pre id="ce6f0eae-58af-4668-921d-617981f6f5d1" class="code"><code>const obj = {name: "Alice", age: 25};
const jsonString = JSON.stringify(obj);
console.log(jsonString); // '{"name":"Alice","age":25}'</code></pre><p id="67676e00-b2ae-4472-818c-72a687259a23" class=""><strong>JSON.parse()</strong>:</p><ul id="b508cb96-0ea8-449b-9b42-e5b21979f83e" class="bulleted-list"><li style="list-style-type:disc"><strong>Mô tả</strong>: Chuyển đổi một chuỗi JSON thành một giá trị JavaScript.</li></ul><ul id="f5ab856d-77e8-4023-8fba-9eb718d0260f" class="bulleted-list"><li style="list-style-type:disc"><strong>Ví dụ</strong>:</li></ul><pre id="6ee73025-8440-4d92-aab4-e05b6be14df2" class="code"><code>const jsonString = '{"name":"Alice","age":25}';
const obj = JSON.parse(jsonString);
console.log(obj.name); // 'Alice'</code></pre><hr id="9305fc36-a5fa-4428-a984-09dfa3a5d05a"><h2 id="115f914e-4b2a-47c5-acec-7a75f41be346" class="">Các khái niệm <strong>React </strong></h2><h3 id="61826f83-39c9-44bf-b6d1-49424b7c7e81" class="block-color-yellow_background"><strong>1. React</strong></h3><ul id="cfbd2ad9-b1c2-4d17-af75-ca5e8f938f8b" class="bulleted-list"><li style="list-style-type:disc"><strong>Definition</strong>: Thư viện JavaScript của Facebook giúp xây dựng UI.</li></ul><pre id="47651b69-d3a8-4691-a2d3-e94ca90dcda3" class="code"><code>import React from 'react';
import ReactDOM from 'react-dom';

function App() {
    return &lt;h1&gt;Hello, React!&lt;/h1&gt;;
}

ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));</code></pre><h3 id="15b5a524-3d76-4067-a358-5396841aed46" class="block-color-yellow_background"><strong>2. JSX</strong></h3><ul id="6751f01a-cba6-46e8-8358-02d2faf58a70" class="bulleted-list"><li style="list-style-type:disc"><strong>Định nghĩa</strong>: Cú pháp mở rộng cho JavaScript cho phép viết mã giống HTML.</li></ul><pre id="a0e3ffb1-d5cc-463f-bb97-2f37f3b5a450" class="code"><code>const element = &lt;h1&gt;Hello, JSX!&lt;/h1&gt;;</code></pre><h3 id="bcad6fff-9ae3-407b-a618-b138d40c778a" class="block-color-yellow_background"><strong>3. Lifecycle of Component</strong></h3><ul id="f085bfb7-289b-4c6d-bfad-7259bd12a679" class="bulleted-list"><li style="list-style-type:disc"><strong>Mô tả</strong>: Giai đoạn mà component trải qua từ khi tạo đến khi hủy.</li></ul><pre id="002689fb-ecaa-418d-ab9b-70af9dd520c7" class="code"><code>import React, { Component } from 'react';

class ExampleComponent extends Component {
    constructor(props) {
        super(props);
        console.log('Constructor - Khởi tạo');
    }

    componentDidMount() {
        console.log('componentDidMount - Gán vào Component');
    }

    componentDidUpdate() {
        console.log('componentDidUpdate - Cập nhật Component');
    }

    componentWillUnmount() {
        console.log('componentWillUnmount - Hủy khỏi Component');
    }

    render() {
        return &lt;h1&gt;Hello, Lifecycle!&lt;/h1&gt;;
    }
}</code></pre><ul id="4450883b-5256-4663-8eb7-41b29b804751" class="bulleted-list"><li style="list-style-type:disc"><strong>Từ React 16.3 trở đi</strong>, một số phương thức vòng đời mới đã được giới thiệu và một số phương thức cũ không an toàn đã được đánh dấu là sắp bị khai tử:</li></ul><pre id="cbf7c6b5-70b2-40a5-82e3-efdad7ea4061" class="code"><code>import React, { useState, useEffect } from 'react';

function DemoHookComponent() { 
  const [count, setCount] = useState(0); //Initialization (Khởi tạo): 1

  useEffect(() =&gt; {
    console.log('Component đã được gắn kết hoặc cập nhật.'); // Mounting (Gắn kết): 2
    return () =&gt; {
      console.log('Cleanup: Component sắp được gỡ bỏ hoặc trước khi cập nhật lại.'); //5
    }
  });

  return ( // Rendering 3
    &lt;div&gt;
      &lt;p&gt;Đếm: {count}&lt;/p&gt; 
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Tăng&lt;/button&gt;; //Updating (Cập nhật) 4
    &lt;/div&gt;
  );
}

export default DemoHookComponent;</code></pre><h3 id="707dabc8-f5a0-4adf-b2fe-387a1278e777" class="block-color-yellow_background"><strong>4. Types of Components</strong></h3><ul id="c2cc8d97-1180-46d2-9973-ea805321e3de" class="bulleted-list"><li style="list-style-type:disc"><strong>Class component</strong>: Viết dưới dạng class ES6, là một class ES6 kế thừa từ <code><strong>React.Component</strong></code>.</li></ul><p id="391b62f3-1ae6-4e93-84e4-a0b75b94c3d3" class=""><strong>Cách hoạt động</strong>:</p><ol type="1" id="56cc7d30-a968-4809-9a16-f3ae8d882556" class="numbered-list" start="1"><li>Có một phương thức <code><strong>render()</strong></code> bắt buộc, trả về JSX.</li></ol><ol type="1" id="aea0ce6b-3a07-4ecd-aea6-dd8b01b8c151" class="numbered-list" start="2"><li>Có thể sử dụng trạng thái (state) và vòng đời (lifecycle methods).</li></ol><ol type="1" id="5b13e792-feb4-4c1c-a360-417566c62f63" class="numbered-list" start="3"><li>Trạng thái được quản lý bên trong component và có thể thay đổi theo thời gian.</li></ol><pre id="2395f7be-9b10-4f0a-a553-4deaa58a3729" class="code"><code>// Class Component
class ClassComponent extends React.Component {
    render() {
        return &lt;h1&gt;Hello from Class Component!&lt;/h1&gt;;
    }
}</code></pre><ul id="0949fbbb-e504-4f83-b04c-cf371cb9764a" class="bulleted-list"><li style="list-style-type:disc"><strong>Function component</strong>: Viết dưới dạng hàm, là một hàm JavaScript, trả về JSX..</li></ul><p id="0a3bd73f-7929-4ef2-8ec2-29292dc7c4ad" class=""><strong>Cách hoạt động</strong>:</p><ol type="1" id="9c930e1b-7fab-4f8a-aa58-145d4293c42d" class="numbered-list" start="1"><li>Trước đây, thường chỉ sử dụng cho các component không có trạng thái hoặc logic phức tạp.</li></ol><ol type="1" id="2f199336-d270-4ca9-8c00-e5d38552a61e" class="numbered-list" start="2"><li>Với sự giới thiệu của Hooks (từ React 16.8 trở đi), Function Components giờ đây có thể sử dụng trạng thái, vòng đời và nhiều tính năng khác của React.</li></ol><pre id="972c6ac5-b1de-49f2-a7b6-5daefc5dbd1a" class="code"><code>// Function Component
function FunctionComponent() {
    return &lt;h1&gt;Hello from Function Component!&lt;/h1&gt;;
}</code></pre><h3 id="dc4406c7-9f68-4643-b4f4-0dd68fdfeff1" class="block-color-yellow_background"><strong>5. State/Props</strong></h3><ul id="d39f3897-120a-4094-85a5-86d3056b99c5" class="bulleted-list"><li style="list-style-type:disc"><strong>State</strong>: Đối tượng chứa dữ liệu có thể thay đổi.</li></ul><ul id="8ddb4b4b-5f84-456a-83de-98105fb7e001" class="bulleted-list"><li style="list-style-type:disc">Là 1 Component</li></ul><pre id="10e1eeba-688b-4269-990b-4e15084062c0" class="code"><code>class StatefulComponent extends React.Component {
    constructor() {
        super();
        this.state = {
            count: 0
        };
    }

    render() {
        return &lt;h1&gt;{this.state.count}&lt;/h1&gt;;
    }
}</code></pre><ul id="b8df8f15-156d-403e-aaa4-47342bbbdecf" class="bulleted-list"><li style="list-style-type:disc"><strong>Props</strong>: Tham số đầu vào của component.</li></ul><pre id="cee4a98f-d441-40bf-a016-d09f655880bd" class="code"><code>function StatelessComponent(props) {
    return &lt;h1&gt;{props.message}&lt;/h1&gt;;
}</code></pre><h3 id="69ff78cc-0041-40e9-8c72-dd43967f3151" class="block-color-yellow_background"><strong>6. Ref</strong></h3><ul id="f281c6c8-eec6-4be0-8e34-e0dbbb620d25" class="bulleted-list"><li style="list-style-type:disc"><strong>Mô tả</strong>: Truy cập trực tiếp phần tử DOM hoặc instance của component.</li></ul><pre id="82702662-fb08-4178-a9fc-60de47eb38a0" class="code"><code>class RefComponent extends React.Component {
    constructor(props) {
        super(props);
        this.myRef = React.createRef();
    }

    componentDidMount() {
        this.myRef.current.focus();
    }

    render() {
        return &lt;input ref={this.myRef} /&gt;;
    }
}</code></pre><h3 id="4cd86b5d-ff06-44ec-9327-d41780cb7430" class="block-color-yellow_background"><strong>7. Handle Event</strong></h3><ul id="f960d35c-aefb-4bc5-975e-97fb45393fca" class="bulleted-list"><li style="list-style-type:disc"><strong>Mô tả</strong>: Xử lý sự kiện như click, input, etc.</li></ul><pre id="2a111033-5984-41dd-b862-8e8fe1275de6" class="code"><code>class EventComponent extends React.Component {
    handleClick() {
        alert('Button was clicked!');
    }

    render() {
        return &lt;button onClick={this.handleClick}&gt;Click Me!&lt;/button&gt;;
    }
}</code></pre><h3 id="fe2541bd-d4bb-4f12-ba55-b89b2fd8df0a" class="block-color-yellow_background"><strong>8. React Hook + Lifecycle</strong></h3><ul id="0f511b70-1a66-4e8d-9fbb-c552dfe6eca1" class="bulleted-list"><li style="list-style-type:disc"><strong>Hooks</strong>: Functions kết nối tính năng React mà không cần class.</li></ul><pre id="b42cdce1-8655-4765-ac7b-8101fb5d77a5" class="code"><code>import { useState, useEffect } from 'react';

function HookComponent() {
    const [count, setCount] = useState(0);

    useEffect(() =&gt; {
        document.title = `You clicked ${count} times`;

        return () =&gt; {
            console.log('Cleanup on component unmount');
        };
    }, [count]);

    return (
        &lt;div&gt;
            &lt;p&gt;You clicked {count} times&lt;/p&gt;
            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Click me&lt;/button&gt;
        &lt;/div&gt;
    );
}</code></pre><h3 id="6e704061-8312-4a21-af46-b6f8d939eb5c" class="block-color-yellow_background"><strong>9.  useCallback và useMemo </strong></h3><ul id="bdca5b5e-7d11-4db7-8947-83c24fa686e6" class="bulleted-list"><li style="list-style-type:disc">    <code><strong>useCallback</strong></code> là một hook trong React được sử dụng để tránh việc tạo ra một function mới mỗi khi component được re-render.</li></ul><ul id="a78ba344-7183-4876-9a28-339f243b35c8" class="bulleted-list"><li style="list-style-type:disc"> Nó nhận vào hai tham số: một function và một mảng dependencies. Khi các dependencies không thay đổi qua các lần re-render, <code><strong>useCallback</strong></code> sẽ trả lại phiên bản cũ của function, thay vì tạo ra một bản mới.</li></ul><ul id="908d3771-211c-4b03-9988-11e7368fad31" class="bulleted-list"><li style="list-style-type:disc">Điều này hữu ích khi bạn muốn tránh việc re-render không cần thiết của các component con khi truyền function như props.</li></ul><p id="a1abec48-b359-48a5-9a15-ad7ada2a48cd" class="">  </p><div class="indented"><pre id="d23caaf6-cdd0-4b3e-a282-ac796f797dda" class="code"><code>import React, { useCallback, useEffect, useState } from "react";

function FnCallback () {
     // Giả sử state ban đầu là một mảng có 5 phần tử
  const [items, setItems] = useState([1, 2, 3, 4, 5]);

    // Hàm callback được định nghĩa thông qua useCallback
  const deletedItem = useCallback(() =&gt; {
    if (items.length &gt; 7) {
        // Bạn có thể thêm logic xử lý ở đây

        setItems(prevItems =&gt; prevItems.slice(0, -1)); // xóa phần tử cuối cùng
        return  alert('Số lượng phần tử đã vượt quá giới hạn!');
        
    }
  },[items])


  useEffect(() =&gt; {
    // Khi số lượng phần tử vượt quá 7
    deletedItem()
  }, [items, deletedItem]);

  return (
    &lt;div&gt;
      &lt;ul&gt;
        {items.map(item =&gt; (
          &lt;li key={item}&gt;{item}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
      &lt;button onClick={() =&gt; setItems([...items, items.length + 1])}&gt;
        Thêm phần tử
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

export default FnCallback;
// Ban đầu, items là một mảng có 5 phần tử.
//Khi người dùng nhấp vào nút "Thêm phần tử", một phần tử mới sẽ được thêm vào mảng.
//useEffect theo dõi sự thay đổi của items.
//Khi số lượng phần tử trong items vượt quá 7, hàm deletedItem sẽ được gọi.</code></pre><p id="653fc8ee-2c26-4690-83c4-971ac2787ba2" class="">
</p><ul id="96ceca23-d778-4a43-8996-4cc2f1460248" class="bulleted-list"><li style="list-style-type:disc"><code><strong>useMemo</strong></code> giúp tránh việc tính toán lại giá trị mỗi khi component re-render, trừ khi một trong các dependencies đã thay đổi. </li></ul><ul id="f01cf2cf-2b32-4b62-a410-f2bd85e12d4a" class="bulleted-list"><li style="list-style-type:disc">Điều này hữu ích cho các tính toán phức tạp mà bạn không muốn thực hiện mỗi lần component re-render.</li></ul><ul id="beb34173-83ae-4c89-b0b0-094d56d6e595" class="bulleted-list"><li style="list-style-type:disc"><code><strong>useMemo</strong></code> cũng nhận hai tham số: một function tạo ra giá trị cần được ghi nhớ và một mảng dependencies.</li></ul><pre id="ddbee181-0d63-4aa7-a38a-b454c842bf38" class="code"><code>function Total({ numbers }) {
  const total = useMemo(() =&gt; {
    console.log("Tính toán tổng...");
    return numbers.reduce((sum, num) =&gt; sum + num, 0);
  }, [numbers]);

  return &lt;div&gt;Tổng: {total}&lt;/div&gt;;
}
//mỗi khi numbers thay đổi, useMemo sẽ thực hiện tính toán mới. 
//Nhưng nếu numbers không thay đổi giữa các lần render, nó sẽ sử dụng giá trị memoized, tránh việc thực hiện các tính toán không cần thiết.</code></pre><ul id="1f4a3028-9e28-4d54-8a72-5299fb329027" class="toggle"><li><details open=""><summary><strong>Sự khác biệt giữa hai cái</strong>:</summary><ul id="f405d134-eddc-45a8-b799-67539ebfffef" class="bulleted-list"><li style="list-style-type:disc">Mặc dù cả hai đều dựa trên khái niệm memoization và đều sử dụng một mảng dependencies, <code><strong>useCallback</strong></code> trả lại một function memoized trong khi <code><strong>useMemo</strong></code> trả lại giá trị mà function tạo ra.</li></ul></details></li></ul><p id="9952b369-47fc-425d-9dcd-c3689a5a9ee2" class=""><strong>Về hiệu suất</strong>:</p><ul id="e5a1413e-6757-45ba-aa89-9f4f8ba09a02" class="bulleted-list"><li style="list-style-type:disc">Sử dụng <code><strong>useCallback</strong></code> và <code><strong>useMemo</strong></code> không phải lúc nào cũng mang lại lợi ích về hiệu suất. Thực tế, trong nhiều trường hợp, việc sử dụng chúng mà không cần thiết có thể làm giảm hiệu suất bởi vì việc tạo ra các hooks cũng tốn một chút thời gian. Chính vì vậy, bạn nên chỉ sử dụng chúng khi thực sự cần thiết và sau khi đã đo lường hiệu suất.</li></ul></div><p></p><hr id="8c4fb6a7-9ce9-4445-b38d-b604edca7b97"><h2 id="5cfe2be8-806f-4006-af91-cb52309cb40d" class=""><strong>Advanced JavaScript Techniques</strong></h2><h3 id="b174c076-bd64-4713-9782-5ffaad9d90a5" class="block-color-yellow_background"><strong>1. forEach(Item, index , array)</strong></h3><ul id="004abb7e-a85a-4606-b389-f31853385c13" class="bulleted-list"><li style="list-style-type:disc"><strong>Mô tả</strong>: Thực thi hàm cho mỗi phần tử. Không trả về mảng mới.</li></ul><pre id="6344f88f-6d50-4f4f-8027-c883c8c3ee65" class="code"><code>const numbers = [1, 2, 3];
numbers.forEach(num =&gt; console.log(num));d</code></pre><h3 id="0a19e9ca-cb0b-4a77-ab34-38930ada6a4d" class="block-color-yellow_background"><strong>2. filter(value, index, array)</strong></h3><ul id="e3307100-cfba-4148-ad41-fd6eb23a8980" class="bulleted-list"><li style="list-style-type:disc"><strong>Mô tả:  </strong>Tìm kiếm phần tử trong hàm </li></ul><ul id="51d53278-9451-42b5-bcea-96f5b9001b01" class="bulleted-list"><li style="list-style-type:disc">Phương thức <code><strong>filter</strong></code> của mảng (Array) trong JavaScript trả về một mảng mới. Các phần tử của mảng mới này là những phần tử từ mảng gốc đã thỏa mãn điều kiện (được kiểm tra thông qua hàm callback mà bạn truyền vào <code><strong>filter</strong></code>).</li></ul><pre id="941e3725-67df-4900-b47b-a2d1070ca5f7" class="code"><code>const numbers = [1, 2, 3, 4];
const evenNumbers = numbers.filter(num =&gt; num % 2 === 0);
console.log(evenNumbers);</code></pre><h3 id="68bc8a79-96d1-4461-9c06-f68ee46caef4" class="block-color-yellow_background"><strong>3. map(Item, index , array)</strong></h3><ul id="2d5a92dd-ff24-4942-9490-b352b23ee1d6" class="bulleted-list"><li style="list-style-type:disc"><strong>Mô tả</strong>: Tạo mảng mới dựa trên biến đổi nào đó.</li></ul><pre id="678df4af-aac5-458c-a9ee-78d219da21c8" class="code"><code>const numbers = [1, 2, 3];
const doubledNumbers = numbers.map(num =&gt; num * 2);
console.log(doubledNumbers);</code></pre><h3 id="65f6d86a-796a-4203-8a71-d99d1dbc1a4c" class="block-color-yellow_background"><strong>4. reduce(previousValue , currentValue , currentIndex , Array )</strong></h3><ul id="98745858-5db9-4895-95d4-8d0d26175232" class="bulleted-list"><li style="list-style-type:disc"><strong>Mô tả</strong>: Biến đổi mảng dựa trên giá trị tích lũy.</li></ul><pre id="f22fc916-5552-4aa2-a45c-a0ec1b30c9cd" class="code"><code>const numbers = [1, 2, 3];
const sum = numbers.reduce((accumulator, num , index , array) =&gt; accumulator + num, 0);
console.log(sum);</code></pre><h3 id="fa778d7e-6aa5-4a85-87c7-e22df7ac241b" class="block-color-yellow_background"><strong>5. Spread &amp; Rest</strong></h3><ul id="85cf54a3-d86d-4474-a203-64df2144cc8a" class="bulleted-list"><li style="list-style-type:disc"><strong>Spread</strong>: "Trải" giá trị ra.</li></ul><pre id="8190e56d-db4d-4b93-908e-63a91948ffb8" class="code"><code>const oldArray = [1, 2, 3];
const newArray = [...oldArray, 4, 5];</code></pre><ul id="ee0deef2-274d-44e3-aa41-397ccee85299" class="bulleted-list"><li style="list-style-type:disc"><strong>Rest</strong>: "Thu gom" giá trị lại.</li></ul><pre id="485a740b-645b-4db9-b2ae-2f3252d52673" class="code"><code>function logArgs(...args) {
    console.log(args);
}

logArgs(1, 2, 3, 4, 5);</code></pre><h3 id="49424266-b7ba-41da-9c23-ccaef6c24b55" class="block-color-yellow_background"><strong>6. Optional chaining</strong></h3><ul id="6efd14cf-ba61-4b3a-9955-28486a0c4f18" class="bulleted-list"><li style="list-style-type:disc"><strong>Mô tả</strong>: Truy cập thuộc tính mà không cần kiểm tra tồn tại.</li></ul><pre id="9be0fe2f-0c7d-4d64-a32b-078a7b54f0fa" class="code"><code>const user = {
    name: "John",
    address: {
        street: "123 Main St."
    }
};

console.log(user?.address?.city);  // Output: undefined without any error</code></pre><hr id="de22439c-cd55-41b3-8048-35c3b3c9374d"><h3 id="208ba8e0-3c5d-4e84-9569-cfd85bca5efe" class=""><strong> Medium React</strong></h3><h3 id="57a5376e-4699-42b9-b0ab-e6651b5a8a07" class="block-color-yellow_background"><strong>1.  Redux + Flux</strong></h3><ul id="9014ad1b-0b19-46cc-86b5-6f1cd8f7113b" class="bulleted-list"><li style="list-style-type:disc">Quá trình làm việc cơ bản của Flux:</li></ul><ol type="1" id="7f56d0b3-5d95-4932-bf5a-642ad704e830" class="numbered-list" start="1"><li>Người dùng tương tác với view.</li></ol><ol type="1" id="41e812ef-d7f7-49ab-a011-2c8077b52a85" class="numbered-list" start="2"><li>View phát ra một action thông qua dispatcher.</li></ol><ol type="1" id="d31ae664-5295-4692-913a-e20540e8b853" class="numbered-list" start="3"><li>Dispatcher thông báo cho store biết về action.</li></ol><ol type="1" id="a1b2038a-3412-4418-8414-7355bef07974" class="numbered-list" start="4"><li>Store xử lý action, thay đổi trạng thái của mình và thông báo cho tất cả views lắng nghe.</li></ol><ol type="1" id="4855809a-9946-48c9-aeef-03dcbe40ab10" class="numbered-list" start="5"><li>Views cập nhật lại dựa trên trạng thái mới từ store.</li></ol><ul id="6c2c6f18-f9b3-4e21-96ca-e27b4bd279c0" class="bulleted-list"><li style="list-style-type:disc"><strong>Actions</strong>: Các sự kiện mà view gửi đi. Actions có thể được gửi tới dispatcher, và sau đó được chuyển đến store tương ứng để xử lý.</li></ul><pre id="1f6d4ecc-b74e-41d3-a950-13d81fdef1b8" class="code"><code>//action 
export const INCREMENT = 'INCREMENT';
export const DECREMENT = 'DECREMENT';

export const increment = () =&gt; ({
    type:INCREMENT
})
export const decrement = () =&gt; ({
    type:DECREMENT
})</code></pre><pre id="2409a822-54c6-4b4c-8917-55474c8ac005" class="code"><code>//reduce
import {DECREMENT, INCREMENT} from '../actions/counterActions'
const initValue = 0 ;
const counterReduce = (state = initValue , action) =&gt; {
    switch (action.type) {
        case INCREMENT:
            return state + 1 
        case DECREMENT:
            return state - 1 
        default:
            return state;
    }
}

export default counterReduce;</code></pre><ul id="0b458843-2e2f-4f8c-9b39-3db2c12bada3" class="bulleted-list"><li style="list-style-type:disc"><strong>Store</strong>: Chứa trạng thái và logic của ứng dụng. Store lắng nghe các sự kiện từ dispatcher và cập nhật trạng thái của nó dựa trên sự kiện đó. Khi trạng thái của store thay đổi, nó sẽ thông báo cho các thành phần (component) liên quan.</li></ul><pre id="e9e31325-93dd-4fd6-81fd-e11dabc858ec" class="code"><code>//store
import { createStore } from "redux";
import counterReduce from "../reducers/counterReducer";

const store = createStore(counterReduce)
export default store;</code></pre><ul id="2f948498-4ae1-4cbd-bdd9-126997330173" class="bulleted-list"><li style="list-style-type:disc"><code><strong>Provider</strong></code> là một component cha được sử dụng để cung cấp (hoặc "provide") dữ liệu hoặc chức năng cho các component con của nó, giúp tránh việc truyền props qua nhiều cấp component</li></ul><pre id="b204bde7-d8b4-4581-946d-70cf5313d42e" class="code"><code>//provider
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';
import { Provider } from 'react-redux';
import store from './components/store/store';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  &lt;Provider store={store}&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;

);

reportWebVitals();</code></pre><ul id="1f2f5517-6564-4b0f-a09e-70d609061627" class="bulleted-list"><li style="list-style-type:disc"><strong>Dispatcher</strong>: Là trung tâm điều phối cho tất cả sự kiện dữ liệu trong ứng dụng. Khi một sự kiện xảy ra (thường được gọi là "action"), dispatcher sẽ nhận biết và thông báo tới tất cả các store liên quan.</li></ul><ul id="478eaf94-b346-444c-bffb-3d1d91449966" class="bulleted-list"><li style="list-style-type:disc"><strong>View</strong>: Thường là các thành phần React. Các view lắng nghe sự thay đổi từ store và cập nhật UI dựa trên trạng thái mới. Khi người dùng tương tác với view, nó có thể phát ra các sự kiện (actions) để thông báo cho hệ thống về sự thay đổi.</li></ul><pre id="d6f10a15-f158-4771-9900-60845b1a40fa" class="code"><code>//view 

import './App.css';
import { useDispatch, useSelector } from 'react-redux';
import { decrement, increment } from './components/actions/counterActions';

function App() {
  const dispatch = useDispatch()
  const counter = useSelector(state =&gt; state)
  return (
    &lt;div className="App"&gt;
       &lt;h1&gt;Counter: {counter}&lt;/h1&gt;
			//increment implement từ //reduce
       &lt;button onClick={() =&gt; dispatch(increment())}&gt;Increment&lt;/button&gt;
       &lt;button onClick={() =&gt; dispatch(decrement())}&gt;Decrement&lt;/button&gt;
    &lt;/div&gt;
  );
}

export default App;</code></pre><h3 id="acdbb9d6-31a5-42d2-80ed-827045a19574" class="block-color-yellow_background"><strong>2.  Phân biệt và cách sử dụng </strong></h3><p id="98f81542-6073-4328-80f1-e90550e1a49e" class="">🏁 <strong>Redux Thunk</strong></p><ul id="90df2d27-551c-4ae5-a5e0-a2cabd9ffd45" class="bulleted-list"><li style="list-style-type:disc"><strong>Là gì?</strong> Redux Thunk là một middleware cho Redux cho phép bạn viết action creators trả về một hàm thay vì một action. Đặc biệt hữu ích khi xử lý các hành động bất đồng bộ.</li></ul><ul id="b99c00af-be46-4e8f-b190-833ed8151e48" class="bulleted-list"><li style="list-style-type:disc"><strong>Cơ bản</strong>: Redux Thunk cho phép bạn gửi function (thunk) thay vì plain actions. Một thunk là một function trả về một function khác mà nó nhận vào hai tham số: <code><strong>dispatch</strong></code> và <code><strong>getState</strong></code>.</li></ul><ul id="b12ca4fb-003d-4e6f-94b7-02e4628289b6" class="bulleted-list"><li style="list-style-type:disc"><strong>Quy trình làm việc</strong>:<ol type="1" id="50c1524d-5df4-4f0a-b2de-a823e589645d" class="numbered-list" start="1"><li>Thunk được dispatch giống như một action bình thường.</li></ol><ol type="1" id="8296fa01-e09b-4f83-ad50-673a116b14ab" class="numbered-list" start="2"><li>Redux Thunk middleware kiểm tra xem action là một function hay không.</li></ol><ol type="1" id="2271795d-7969-4f15-ac41-def879645857" class="numbered-list" start="3"><li>Nếu là một function, middleware sẽ gọi nó, truyền <code><strong>dispatch</strong></code> và <code><strong>getState</strong></code> như là tham số.</li></ol><ol type="1" id="1e59418e-acc3-4880-9cc0-7db0d1490129" class="numbered-list" start="4"><li>Bạn có thể thực hiện logic bất đồng bộ trong thunk và sau đó dispatch một (hoặc nhiều) action thông qua <code><strong>dispatch</strong></code>.</li></ol></li></ul><ul id="5e540d34-c579-4d2a-9d9d-cff610ce7fdf" class="bulleted-list"><li style="list-style-type:disc"><strong>Ví dụ</strong>:</li></ul><pre id="232caee4-cf15-43a1-94f7-7e4fe229dc68" class="code"><code>// Thunk giúp bạn xử lý các hành động bất đồng bộ trong Redux. 

// Action thông thường báo hiệu bắt đầu một yêu cầu
function batDauYeuCau() {
    return { type: 'BAT_DAU' };
}

// Action thông thường khi yêu cầu thành công
function thanhCong(data) {
    return { type: 'THANH_CONG', payload: data };
}

// Action thông thường khi yêu cầu thất bại
function thatBai(error) {
    return { type: 'THAT_BAI', payload: error };
}

// Action Thunk để thực hiện yêu cầu bất đồng bộ
function layDuLieu() {
    return dispatch =&gt; {
        dispatch(batDauYeuCau());  // Bắt đầu yêu cầu
        fetch('/api/duLieu')      // Giả sử bạn đang gọi API
            .then(resp =&gt; resp.json())
            .then(data =&gt; {
                dispatch(thanhCong(data));  // Yêu cầu thành công
            })
            .catch(error =&gt; {
                dispatch(thatBai(error));   // Yêu cầu thất bại
            });
    };
}</code></pre><p id="20a4a741-a986-4809-946a-9f4e853fb791" class="">🏁 <strong>Reselect</strong></p><ul id="2164aa89-0e39-4af4-952c-a8ea5486ca96" class="bulleted-list"><li style="list-style-type:disc"><strong>Là gì?</strong> Reselect là một thư viện giúp tạo ra các selector functions được lưu trữ. Các selectors có thể tính toán dữ liệu dẫn xuất từ Redux store, cho phép Redux lưu trữ trạng thái tối thiểu.</li></ul><ul id="f872248c-5f74-450d-96b9-ea71f48a31ce" class="bulleted-list"><li style="list-style-type:disc"><strong>Cơ bản</strong>: Redux Selector giúp bạn trích xuất dữ liệu từ Redux store. Nó cung cấp một cách để tính toán dữ liệu dựa trên state, giúp tối ưu hóa việc tái sử dụng và tính toán lại.</li></ul><ul id="c61b5dd5-b93a-4b12-994e-43b4892b4cc4" class="bulleted-list"><li style="list-style-type:disc"><strong>Quy trình làm việc</strong>:<ol type="1" id="2c62b7d3-4061-4dfb-85d8-49e7c5e91aec" class="numbered-list" start="1"><li>Tạo một selector function dùng để trích xuất hoặc tính toán dữ liệu từ state.</li></ol><ol type="1" id="8819a1b4-0da9-4449-8fc0-58024d1faf7d" class="numbered-list" start="2"><li>Trong component của bạn, sử dụng <code><strong>useSelector</strong></code> (khi dùng React hooks) hoặc <code><strong>connect</strong></code> (khi dùng HOC) để truy cập dữ liệu thông qua selector.</li></ol><ol type="1" id="363f2393-2e91-4984-baa2-ea46e117ddac" class="numbered-list" start="3"><li>Khi state thay đổi, selector được gọi để kiểm tra xem dữ liệu mà nó trích xuất có thay đổi không. Nếu dữ liệu không thay đổi, component không bị render lại.</li></ol></li></ul><ul id="02f4fecd-617b-4e4f-99ac-8042c62a29de" class="bulleted-list"><li style="list-style-type:disc"><strong>Ví dụ</strong>:</li></ul><pre id="485962ca-31e8-4547-9c52-79f5b4d2bdec" class="code"><code>import React from 'react';
import { createSelector } from 'reselect';

function GetUserFilte() {
    // Giả sử chúng ta có một state giả lập như sau:
    const state = {
        users: [
            { id: 1, name: 'An' },
            { id: 2, name: 'Binh' },
            { id: 3, name: 'Chi' },
            { id: 4, name: 'Dung' },
        ],
        filter: 'Dung'
    };

    // 1. Lấy dữ liệu người dùng từ state
    const GetUser = state =&gt; state.users;

    // 2. Lấy giá trị lọc từ state
    const getFilter = state =&gt; state.filter;

    // 3. Tạo một selector để lấy người dùng đã được lọc
    const getFilteredUsers = createSelector(
        [GetUser, getFilter],
        (user, filter) =&gt; user.filter(user =&gt; user.name.includes(filter))
    );

    // Sử dụng selector với state giả lập
    const filteredUsers = getFilteredUsers(state);

    return (
        &lt;div&gt;
            &lt;h2&gt;Danh sách người dùng đã lọc:&lt;/h2&gt;
            &lt;ul&gt;
                {filteredUsers.map(user =&gt; (
                    &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
                ))}
            &lt;/ul&gt;
        &lt;/div&gt;
    );
}

export default GetUserFilte;</code></pre><p id="e791b6b4-a75b-469b-a911-17262c5ea915" class="">🏁 <strong>Redux Saga</strong></p><ul id="069dfdf3-9152-483e-a21f-308187979ddc" class="bulleted-list"><li style="list-style-type:disc"><strong>Là gì?</strong> Redux Saga là một thư viện giúp quản lý side effects (ví dụ như việc lấy dữ liệu bất đồng bộ) dễ dàng hơn, hiệu quả hơn, dễ kiểm tra hơn và giải quyết lỗi tốt hơn.</li></ul><ul id="f61165c0-8ac3-4be6-9471-7153ffe920f2" class="bulleted-list"><li style="list-style-type:disc"><strong>Cơ bản</strong>: Redux Saga sử dụng Generator functions để làm việc với hiệu ứng bên lề (side effects) như gọi API, thực thi logic bất đồng bộ.</li></ul><ul id="2753b3cb-7626-4cbf-915d-6a00d72f1313" class="bulleted-list"><li style="list-style-type:disc"><strong>Quy trình làm việc</strong>:<ol type="1" id="a15e1208-c745-4b50-ba05-338aa20b85c2" class="numbered-list" start="1"><li>Khi một action được dispatch, saga "nghe" thông qua một effect (<code><strong>take</strong></code>, <code><strong>takeEvery</strong></code>, <code><strong>takeLatest</strong></code>, ...).</li></ol><ol type="1" id="e66438f7-8e8d-4a1f-b726-45477c39b275" class="numbered-list" start="2"><li>Khi một action được "nghe" thấy, một saga khác có thể được kích hoạt để xử lý logic bất đồng bộ.</li></ol><ol type="1" id="5d75ade6-f930-47cf-b534-102ebe1edf1f" class="numbered-list" start="3"><li>Sau khi xử lý xong, saga có thể dispatch một action khác để cập nhật store.</li></ol></li></ul><ul id="79662d87-04f1-4d08-821b-43398fd1e8eb" class="bulleted-list"><li style="list-style-type:disc"><strong>Fork</strong>: dùng cơ chế non - blocking call trên function</li></ul><ul id="f8e70007-bc9c-4d13-ac89-b545b73d7186" class="bulleted-list"><li style="list-style-type:disc"><strong>Call</strong>: dùng để gọi function. Nếu Redux saga return về một promise, tạm dừng saga cho đến khi promise được giải quyết</li></ul><ul id="16b8d298-ff53-4fa8-9183-68d11799a57e" class="bulleted-list"><li style="list-style-type:disc"><strong>Take</strong>: ứng dụng sẽ tạm dừng cho đến khi nhận được action</li></ul><ul id="ea2aa61d-81e7-4257-a719-42b01265ec05" class="bulleted-list"><li style="list-style-type:disc"><strong>Put</strong>: được sử dụng để dispatch một action</li></ul><ul id="a8e44b23-b369-4c8f-a138-4436588f2e61" class="bulleted-list"><li style="list-style-type:disc"><strong>takeEvery</strong>: giúp người dùng theo dõi một action nào đó thay đổi thì gọi một saga nào đó</li></ul><ul id="65448a01-3010-4c59-814e-905e9a7bdcdf" class="bulleted-list"><li style="list-style-type:disc"><strong>akeLa test</strong>: giúp người dùng thực hiện một loạt các actions và trả lại kết quả của của actions cuối cùng</li></ul><ul id="0f1909b3-92ec-4c67-8915-fb767c8e1b5c" class="bulleted-list"><li style="list-style-type:disc"><strong>yield</strong>: giúp chạy tuần tự khi nào trả ra kết quả mới tiếp tục thực hiện action khác</li></ul><ul id="71321f9a-de64-4626-a4cb-fc2260ac0118" class="bulleted-list"><li style="list-style-type:disc"><strong>Select</strong>: giúp chạy một selector function để lấy data từ state có trước</li></ul><ul id="01d9983d-a275-43a7-a9bf-7e52b9f26ce2" class="bulleted-list"><li style="list-style-type:disc"><strong>Ví dụ</strong>:</li></ul><pre id="f3540dcd-bb07-4864-be26-c9550991711a" class="code"><code>import { call, put, takeEvery } from 'redux-saga/effects';

// 1. Saga xử lý việc lấy dữ liệu người dùng
function* layDuLieuNguoiDungSaga(action) {
    try {
        // Sử dụng effect `call` để gọi API
        const nguoiDung = yield call(api.layNguoiDung, action.payload.userId);
        // Khi lấy thành công, gửi hành động thành công bằng effect `put`
        yield put({type: 'LAY_THANH_CONG', nguoiDung});
    } catch (e) {
        // Khi có lỗi, gửi hành động thất bại
        yield put({type: 'LAY_THAT_BAI', thongDiep: e.message});
    }
}

// 2. Saga chính lắng nghe các hành động và chạy Saga tương ứng
function* rootSaga() {
    // Sử dụng effect `takeEvery` để lắng nghe mỗi hành động `LAY_YEU_CAU` và chạy `layDuLieuNguoiDungSaga`
    yield takeEvery('LAY_YEU_CAU', layDuLieuNguoiDungSaga);
}</code></pre><h3 id="302ba72a-d91a-4a15-887f-818d3b214c3a" class="block-color-yellow_background"><strong>3.  useNavigation();</strong></h3><pre id="ebb0fe1a-fcca-4b83-b1a5-18e4eaf3ab48" class="code"><code>import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import { View, Text, Button } from 'react-native';

const Stack = createStackNavigator();

function HomeScreen({ navigation }) {
  return (
    &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}&gt;
      &lt;Text&gt;Home Screen&lt;/Text&gt;
      &lt;Button
        title="Go to Details"
        onPress={() =&gt; navigation.navigate('Details')}
      /&gt;
    &lt;/View&gt;
  );
}

function DetailsScreen() {
  return (
    &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}&gt;
      &lt;Text&gt;Details Screen&lt;/Text&gt;
    &lt;/View&gt;
  );
}

export default function App() {
  return (
    &lt;NavigationContainer&gt;
      &lt;Stack.Navigator initialRouteName="Home"&gt;
        &lt;Stack.Screen name="Home" component={HomeScreen} /&gt;
        &lt;Stack.Screen name="Details" component={DetailsScreen} /&gt;
      &lt;/Stack.Navigator&gt;
    &lt;/NavigationContainer&gt;
  );
}</code></pre><ul id="0030db17-19ee-4422-b09f-aacf0e915396" class="bulleted-list"><li style="list-style-type:disc">Chúng ta tạo ra hai màn hình: <code><strong>HomeScreen</strong></code> và <code><strong>DetailsScreen</strong></code>.</li></ul><ul id="e838bc94-43e7-469f-a267-5e84f685d266" class="bulleted-list"><li style="list-style-type:disc">Sử dụng <code><strong>Stack.Navigator</strong></code> để quản lý việc chuyển đổi giữa các màn hình.</li></ul><ul id="1322988c-8bcd-47b5-a570-f4ac3116b228" class="bulleted-list"><li style="list-style-type:disc">Trong <code><strong>HomeScreen</strong></code>, chúng ta có một nút "Go to Details" cho phép người dùng chuyển đến <code><strong>DetailsScreen</strong></code>.</li></ul><h3 id="1ad74e02-6e85-4d29-ab54-37c9a251dc88" class="block-color-yellow_background"><strong>4.  Mô hình MVC VÀ MVVM</strong></h3><ul id="10aebc1f-205a-4a28-a129-a167c1b52764" class="bulleted-list"><li style="list-style-type:disc"><strong>MVC</strong></li></ul><p id="24d0988b-5b0b-481f-bebf-349c7a827dae" class=""><strong>Model</strong>: Đại diện cho dữ liệu và kinh doanh logic.</p><p id="3e6fd573-7833-45e7-a6f8-d7612638c637" class=""><strong>View</strong>: Đại diện cho giao diện người dùng.</p><p id="540980d4-5b9c-47e9-bf9b-186f702f8a0c" class=""><strong>Controller</strong>: Xử lý logic và sự kiện của giao diện, thường điều khiển cả Model và View.</p><pre id="177b4c57-179e-4311-9d25-ec73568b04d2" class="code"><code>//Model 
export default class TaskModel {
constructor() {
    this.tasks = []
    }
    addTask(task) {
        this.tasks.push(task)
    }
}
</code></pre><pre id="07b7d89a-8010-4c4b-bf7f-58a9cdf65781" class="code"><code>//component chứa view kết hợp với controller
import { useState } from "react";
import TaskModel from "./modelTask";

const model = new TaskModel();
export default function TaskComponent () {
    const[tasks , setTasks] = useState(model.tasks)
    const[newTask , setNewTask] = useState('')

    const handleAddTask = () =&gt; {
        model.addTask(newTask);
        setTasks([...model.tasks])
        setNewTask('')
    }
    return(
        &lt;div&gt;
            &lt;input value={newTask} onChange={(e) =&gt; setNewTask(e.target.value)}/&gt;
            &lt;button onClick={handleAddTask}&gt;Add Task&lt;/button&gt;
            &lt;ul&gt;
                {tasks.map((task, index) =&gt; &lt;li key={index}&gt;{task}&lt;/li&gt;)}
            &lt;/ul&gt;
        &lt;/div&gt;
    )
}</code></pre><ul id="a19ecacb-c796-427d-8ee1-166e7d3c62bd" class="bulleted-list"><li style="list-style-type:disc"><strong>MVVM</strong></li></ul><pre id="3fa50026-f880-4fd8-8848-688e71c06705" class="code"><code>// ViewModel 
// ViewModel: Chứa trạng thái và hành vi của ứng dụng:
import { useState } from "react";

export function useTaskViewModel(){
    const [tasks, setTasks] = useState([]);
    const [newTask, setNewTask] = useState('');

    const addTask = () =&gt; {
        setTasks((prevTasks) =&gt; [...prevTasks, newTask])
        setNewTask('')
    }

    return {
        addTask,
        newTask,
        setNewTask,
        tasks
    };
}</code></pre><pre id="d202e5ea-845d-4655-a849-39f21794cfe1" class="code"><code>//Component (View) Đại diện cho View
import { useTaskViewModel } from "./useTaskViewModel";

export default function TaskComponentWithViewModel (){
    const { addTask, newTask, setNewTask, tasks } = useTaskViewModel();
    
        return(
            &lt;div&gt;
                &lt;input value={newTask} onChange={(e) =&gt; setNewTask(e.target.value)}/&gt;
                &lt;button onClick={addTask}&gt;Add task&lt;/button&gt;
                &lt;ul&gt;
                {Array.isArray(tasks) &amp;&amp; tasks.map((task, index) =&gt; &lt;li key={index}&gt;{task}&lt;/li&gt;)}

                &lt;/ul&gt;
            &lt;/div&gt;
        )
}</code></pre><h3 id="7e43c31c-4e2d-43b3-83c4-8cc94a1e3b77" class="block-color-yellow_background"><strong>5.  Object Modeling (hoặc Object-Oriented Modeling - OOM) là một phương pháp tiếp cận trong phát triển phần mềm dựa trên việc tạo ra mô hình các đối tượng (object) và quan hệ giữa chúng.</strong></h3><h3 id="807fcfa7-0cb0-4bb3-ad69-e1c14204e172" class=""><strong>1. Các khái niệm cơ bản:</strong></h3><p id="d9c8b349-efbe-48ce-a440-75c9c2f436d1" class=""><strong>1.1. Đối tượng (Object)</strong>: Đại diện cho một thực thể hoặc sự vật nào đó trong thế giới thực.</p><p id="52972860-edf2-4c15-9328-a41e48c27c5c" class=""><strong>1.2. Lớp (Class)</strong>: Là một khuôn mẫu (template) mô tả cấu trúc và hành vi của một nhóm đối tượng tương tự.</p><p id="f057c807-bcbe-4953-993d-6d58d5d028fc" class=""><strong>1.3. Thuộc tính (Attribute)</strong>: Đặc điểm hoặc thông tin liên quan đến đối tượng.</p><p id="77451ed3-c98b-4819-b46f-d5d0caf4eefc" class=""><strong>1.4. Phương thức (Method)</strong>: Hành động mà đối tượng có thể thực hiện.</p><p id="63f0e6ad-8f0c-413c-adf6-734805e5c146" class=""><strong>2. Ưu điểm của Object Modeling:</strong></p><ul id="1fbdbe69-6e6c-4161-99a7-9b981d1ade74" class="bulleted-list"><li style="list-style-type:disc"><strong>Tính trừu tượng</strong>: Cho phép bạn tập trung vào những yếu tố quan trọng nhất và bỏ qua những chi tiết không cần thiết.</li></ul><ul id="9867bbaf-d912-437e-962b-0b6dba003c0e" class="bulleted-list"><li style="list-style-type:disc"><strong>Tái sử dụng</strong>: Các lớp có thể tái sử dụng trong các dự án khác nhau.</li></ul><ul id="19582a10-dd1f-45c8-991d-c8f514c36b7c" class="bulleted-list"><li style="list-style-type:disc"><strong>Mô hình hóa dựa trên thế giới thực</strong>: Dễ dàng hiểu và giải quyết vấn đề hơn.</li></ul><p id="32930d45-6a1b-4a40-84ef-3685c994bb12" class=""><strong>3. Công cụ:</strong></p><p id="fc9627d6-4d81-4802-bd3e-10cc0108a069" class="">Có nhiều công cụ giúp bạn thực hiện object modeling, như:</p><ul id="a97538b6-d566-49f6-84a8-1013e8862329" class="bulleted-list"><li style="list-style-type:disc"><strong>UML (Unified Modeling Language)</strong>: Là một ngôn ngữ mô hình hóa tiêu chuẩn dùng để biểu diễn và trực quan hóa các dự án phần mềm.</li></ul><h3 id="d917a5a5-627e-47be-adce-197709c8eaf9" class="block-color-yellow_background"><strong>6.  Regular expression react </strong></h3><ul id="542ab3d5-e0b2-42f6-80b7-8e4f8902601d" class="bulleted-list"><li style="list-style-type:disc">"Regular expression" (hay biểu thức chính quy) là một công cụ mạnh mẽ dùng để tìm kiếm và thay thế chuỗi dựa trên một mô hình cụ thể.</li></ul><pre id="087fd5ff-fa76-4e10-a233-7d484e65970d" class="code"><code>const emailRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}$/;

  const handleEmailChange = (e) =&gt; {
    const inputValue = e.target.value;
    setEmail(inputValue);

    // Kiểm tra email có hợp lệ không
    setIsValid(emailRegex.test(inputValue));
  };</code></pre><h3 id="4de32487-b56d-458d-9777-aa648946c4d4" class="block-color-yellow_background">7<strong>.  CSS pre-processor</strong></h3><p id="8179290c-3381-4c9c-b6db-842ec3d48b5c" class=""><strong>LESS (Leaner Style Sheets)</strong>:</p><ul id="568df689-aec2-4281-b256-fa491578a31c" class="bulleted-list"><li style="list-style-type:disc"><strong>Cú pháp</strong>: LESS sử dụng cú pháp giống SCSS và CSS, với dấu ngoặc nhọn <code><strong>{}</strong></code> và dấu chấm phẩy <code><strong>;</strong></code>.</li></ul><ul id="c2baf4d1-8a68-4a80-be75-18014159025e" class="bulleted-list"><li style="list-style-type:disc"><strong>Biến</strong>: Sử dụng dấu <code><strong>@</strong></code> để khai báo biến. Ví dụ: <code><strong>@font-size: 16px</strong></code>.</li></ul><ul id="352cb6db-e834-4f02-8c40-fc5450f87105" class="bulleted-list"><li style="list-style-type:disc"><strong>Môi trường</strong>: LESS chủ yếu được biên dịch bằng JavaScript và thường chạy trên Node.js. Tuy nhiên, có thể biên dịch trực tiếp trong trình duyệt, mặc dù không được khuyến khích cho môi trường sản xuất.</li></ul><pre id="ce2967e8-e085-4f91-ae75-f0012ba9af4b" class="code"><code>@base-color: #3498db;

.container {
  background-color: @base-color;
  .button {
    padding: 5px 10px;
    color: darken(@base-color, 10%);
  }
}</code></pre><p id="1df9c936-851f-4e19-affb-17cc124c19c7" class=""><strong>SASS (Phiên bản ban đầu của SASS)</strong></p><ul id="cd015439-6b5d-4d76-bb9a-8bb9a6951195" class="bulleted-list"><li style="list-style-type:disc"><strong>Cú pháp</strong>: SASS sử dụng cú pháp dựa trên indent (không dùng dấu ngoặc nhọn <code><strong>{}</strong></code> hoặc dấu chấm phẩy <code><strong>;</strong></code>). Mọi thứ dựa vào khoảng cách và indent để định nghĩa cấu trúc và quan hệ giữa các bộ chọn và thuộc tính.</li></ul><ul id="713566ed-ee0c-442f-ac51-f2e9304ceb0e" class="bulleted-list"><li style="list-style-type:disc"><strong>Biến</strong>: Bắt đầu với dấu <code><strong>$</strong></code>. Ví dụ: <code><strong>$font-size: 16px;</strong></code>.</li></ul><pre id="3d97406a-c55b-4fa8-bcf4-bc78eb7ee11f" class="code"><code>$base-color: #3498db
.container
  background-color: $base-color
  .button
    padding: 5px 10px
    color: darken($base-color, 10%)</code></pre><p id="10f41171-5a19-4b4d-b257-18371df05e96" class=""><strong>SCSS (Sassy CSS)</strong></p><ul id="b88a319c-e8e2-443b-8b91-66b9339aa346" class="bulleted-list"><li style="list-style-type:disc"><strong>Cú pháp</strong>: Cú pháp của SCSS giống hệt cú pháp của CSS truyền thống. SCSS sử dụng dấu ngoặc nhọn <code><strong>{}</strong></code> và dấu chấm phẩy <code><strong>;</strong></code>, làm cho việc chuyển đổi giữa CSS và SCSS dễ dàng.</li></ul><ul id="d5dc7a4b-5898-4e92-84eb-1c8f6dfbe517" class="bulleted-list"><li style="list-style-type:disc"><strong>Biến</strong>: Giống như SASS, SCSS cũng sử dụng dấu <code><strong>$</strong></code> cho biến.</li></ul><pre id="4ef3a49e-7bfd-430c-a094-8b2e585e9ea9" class="code"><code>$base-color: #3498db;

.container {
  background-color: $base-color;
  .button {
    padding: 5px 10px;
    color: darken($base-color, 10%);
  }
}</code></pre><p id="6dce3fe7-44b3-459c-8397-4880655aec66" class=""><strong>Tính năng chung Scss và Sass :</strong></p><ul id="948caad3-b3f6-446d-b7c3-a60006aa90de" class="bulleted-list"><li style="list-style-type:disc"><strong>Biến</strong>: Định nghĩa giá trị có thể tái sử dụng.</li></ul><ul id="1e13b7b7-045a-4a10-88c3-8fddccfd1ad6" class="bulleted-list"><li style="list-style-type:disc"><strong>Mixins</strong>: Cho phép bạn tạo các định nghĩa CSS có thể tái sử dụng.</li></ul><ul id="3dc3232f-e9bc-4dff-bdfd-428b48b96aa8" class="bulleted-list"><li style="list-style-type:disc"><strong>Lồng nhau</strong>: Cú pháp cho phép bạn lồng các bộ chọn CSS.</li></ul><ul id="fa34dfc1-16b0-4eab-800d-32dd273be06b" class="bulleted-list"><li style="list-style-type:disc"><strong>Phân chia &amp; Nhập</strong>: Chia mã thành các tệp nhỏ và sau đó nhập chúng.</li></ul><ul id="2c7f6335-7939-404e-b18c-ecfa7cfe716a" class="bulleted-list"><li style="list-style-type:disc"><strong>Hàm &amp; Toán tử</strong>: Cho phép bạn thực hiện các phép tính và biến đổi trực tiếp trong CSS của bạn.</li></ul><h3 id="b5089037-5969-48c3-8e90-6e5954bb42bc" class="block-color-yellow_background">8<strong>.  API (Application Programming Interface)</strong> </h3><p id="bdba3f7f-5851-4618-bb4a-be051cd59f0e" class="">là một tập hợp các quy tắc và giao thức giúp các ứng dụng phần mềm giao tiếp với nhau. Nó xác định các phương thức và cấu trúc dữ liệu mà các nhà phát triển có thể sử dụng để tương tác với các thành phần phần mềm, như hệ điều hành, thư viện hoặc các dịch vụ khác nhau.</p><ul id="c93bda38-7f2b-448e-8cbb-ba81852c85df" class="bulleted-list"><li style="list-style-type:disc"><strong>Endpoint</strong>: Là URL mà ứng dụng của bạn gửi yêu cầu đến (ví dụ: <code><strong>https://api.thoitiet.com/v1/forecast</strong></code>).</li></ul><ul id="ee9313e3-4683-4b76-82e1-a92464ac2ea2" class="bulleted-list"><li style="list-style-type:disc"><strong>Phương thức</strong>: Là loại hành động mà bạn muốn thực hiện, thường là GET (để lấy dữ liệu).</li></ul><ul id="ae6f3bab-7fd3-48d9-82fc-c6801a8d997f" class="bulleted-list"><li style="list-style-type:disc"><strong>Định dạng dữ liệu</strong>: Cách dữ liệu được gửi hoặc nhận về, thường là JSON hoặc XML.</li></ul><ul id="8401386e-aa40-40b0-a656-e4ee9136e7e9" class="bulleted-list"><li style="list-style-type:disc"><strong>Tham số</strong>: Là dữ liệu cần thiết cho API, ví dụ: mã thành phố hoặc tên quốc gia để lấy thông tin thời tiết cho địa điểm đó.(ví dụ: <a href="https://api.thoitiet.com/v1/forecast/"><code><strong>https://api.thoitiet.com/v1/forecast</strong></code></a><a href="https://api.thoitiet.com/v1/forecast/"><strong>/</strong></a><strong> + ID</strong>)</li></ul><ul id="2b8ba8b3-2614-4244-b935-4cae18173268" class="bulleted-list"><li style="list-style-type:disc"><strong>Mã phản hồi</strong>: Thông báo về trạng thái của yêu cầu (ví dụ: <code><strong>200 OK</strong></code> cho biết yêu cầu thành công, <code><strong>404 Not Found</strong></code> cho biết không tìm thấy thông tin).</li></ul><h3 id="89fbef2d-ce7a-424e-9916-13c093e8afc0" class="block-color-yellow_background">9<strong>.  </strong>Fetch/ request API/ <strong><strong>axios:</strong></strong></h3><p id="b1c8aa50-8aed-4a22-83a5-d9abd7aad63d" class="">"Fetch" hoặc "request" tới một API đề cập đến việc gửi một yêu cầu từ ứng dụng của bạn đến một dịch vụ API ngoài, sau đó nhận dữ liệu trả về từ dịch vụ đó.</p><ul id="8c50ebd9-eb3c-4e18-b8c2-b80fe192d45d" class="bulleted-list"><li style="list-style-type:disc">Là một API tiêu chuẩn do trình duyệt cung cấp. Không cần cài đặt thư viện hoặc package bên ngoài.</li></ul><ul id="d1d8269e-11ba-453d-8657-bfbd0499a519" class="bulleted-list"><li style="list-style-type:disc">Hỗ trợ Promises nguyên bản.</li></ul><ul id="955099df-d797-4dd3-aa98-e3e9038ad78c" class="bulleted-list"><li style="list-style-type:disc">Không tự động chuyển đổi dữ liệu phản hồi sang JSON, bạn cần làm thêm bước này.</li></ul><ul id="e6b0667d-bd05-47d0-9a26-b9df1b1f374d" class="bulleted-list"><li style="list-style-type:disc">Để xử lý lỗi, bạn cần kiểm tra <code><strong>response.ok</strong></code> vì <code><strong>fetch</strong></code> chỉ reject promise khi gặp lỗi mạng.</li></ul><p id="a806637a-2b38-4373-b33a-5f386a33d7f7" class="">Trong web development, API thường được gọi thông qua giao thức HTTP hoặc HTTPS. Có nhiều phương thức HTTP, trong đó phổ biến nhất là:</p><ul id="92ffbbbd-72a2-4f12-b876-55183d27eac1" class="bulleted-list"><li style="list-style-type:disc"><strong>GET</strong>: Để lấy dữ liệu</li></ul><ul id="9e408bc4-3a0a-4d12-a0ad-5f61d7368ae2" class="bulleted-list"><li style="list-style-type:disc"><strong>POST</strong>: Để tạo dữ liệu mới</li></ul><ul id="63d9c977-eb10-415b-8ff0-bbafe6a48560" class="bulleted-list"><li style="list-style-type:disc"><strong>PUT</strong> hoặc <strong>PATCH</strong>: Để cập nhật dữ liệu</li></ul><ul id="c3a89b2b-2dc2-42b5-9c79-f3b19be7c1b3" class="bulleted-list"><li style="list-style-type:disc"><strong>DELETE</strong>: Để xóa dữ liệu</li></ul><pre id="304eb0c0-c7f4-4d27-a07a-cec8c4ef81a7" class="code"><code>fetch('https://api.thoitiet.com/v1/forecast?city=Hanoi')
  .then(response =&gt; response.json())
  .then(data =&gt; {
    console.log(data); // Xem dữ liệu thời tiết trả về cho thành phố Hà Nội
  })
  .catch(error =&gt; {
    console.error('Có lỗi xảy ra khi gọi API:', error);
  });</code></pre><h3 id="d342c9fe-3ba0-451d-ad70-a542dde3c11f" class=""><strong>axios:</strong></h3><ul id="5708115f-2bab-448b-a720-e783a1d079c6" class="bulleted-list"><li style="list-style-type:disc">Là một thư viện HTTP client dựa trên promise. Bạn cần cài đặt nó thông qua npm hoặc yarn.</li></ul><ul id="e32a1a54-0544-481b-b55e-2333d59bd884" class="bulleted-list"><li style="list-style-type:disc">Hỗ trợ cả callback và async/await.</li></ul><ul id="39f8ea4e-eb3c-408b-a35b-0a329d8e7852" class="bulleted-list"><li style="list-style-type:disc">Tự động chuyển đổi dữ liệu phản hồi sang JSON.</li></ul><ul id="cac3a511-2beb-4a21-abcd-6099072f6e8d" class="bulleted-list"><li style="list-style-type:disc">Reject promise khi gặp một phản hồi HTTP không thành công, giúp việc xử lý lỗi dễ dàng hơn.</li></ul><ul id="7b487a4a-90e6-4135-b49f-d9f64b657f7d" class="bulleted-list"><li style="list-style-type:disc">Hỗ trợ hủy yêu cầu và theo dõi tiến trình tải lên.</li></ul><pre id="180d2f46-e012-449a-801c-be5b28d47f70" class="code"><code>axios.get('https://api.example.com/data')
  .then(response =&gt; console.log(response.data))
  .catch(error =&gt; console.error('Error fetching data:', error));</code></pre><p id="5dce3ec2-4860-481c-8547-243dd05050f7" class=""><strong>Kết luận</strong>:</p><ul id="31028c78-4091-4e00-acee-f99264ee5f6f" class="bulleted-list"><li style="list-style-type:disc"><code><strong>fetch</strong></code> là lựa chọn tốt nếu bạn muốn sử dụng một giải pháp tiêu chuẩn không cần thêm thư viện.</li></ul><ul id="e182a2ae-2b3d-44c7-9b60-081e1e237d3c" class="bulleted-list"><li style="list-style-type:disc"><code><strong>axios</strong></code> cung cấp nhiều tính năng và tiện ích hơn, đặc biệt trong việc xử lý lỗi và khi cần một HTTP client mạnh mẽ hơn cho ứng dụng của bạn.</li></ul><ul id="f85b2a48-f74a-424f-aafc-9baa7c2704b0" class="bulleted-list"><li style="list-style-type:disc"><code><strong>axios</strong></code> mang lại nhiều tính năng mà <code><strong>fetch</strong></code> không có nguyên bản. Dưới đây là một số ví dụ minh họa cho các tính năng đó</li></ul><p id="88ac75db-5b31-4cb2-8238-febbc88bf5fe" class=""><strong>Xử lý lỗi tự dộng:</strong></p><p id="75f1003f-73d2-4bf5-8a86-b0a1430b9698" class=""><code><strong>axios</strong></code> sẽ tự động reject promise khi có một phản hồi HTTP không thành công.</p><pre id="487bcdc6-ad98-4176-9553-bb66b17a4952" class="code"><code>// Với axios
axios.get('https://api.example.com/not-found-endpoint')
  .catch(error =&gt; console.error('Lỗi:', error.message));</code></pre><p id="a5cd7b90-2fd2-45cb-bf2f-1ac5040ef9bb" class=""><strong>Chuyển đổi dữ liệu phản hồi sang JSON tự động</strong>:</p><p id="7e10d077-9e00-4ee8-bc81-7ceb6d49fd1f" class=""><code><strong>axios</strong></code> tự động chuyển đổi dữ liệu phản hồi sang JSON, không cần gọi thêm <code><strong>response.json()</strong></code> như <code><strong>fetch</strong></code></p><pre id="e942c046-da8d-4cab-a9dd-d5a19bab6b2e" class="code"><code>// Với axios
axios.get('https://api.example.com/data')
  .then(response =&gt; console.log(response.data));</code></pre><p id="1acaebd8-5181-46ac-a58d-d6b2949dfa18" class=""><strong>Hủy yêu cầu</strong>:</p><p id="2923acd5-765f-4e9e-91d8-3eef2084937a" class=""><code><strong>axios</strong></code> cho phép bạn hủy một yêu cầu đang chạy.</p><pre id="94aa8598-9eba-4ab9-9ab1-1829c72570a8" class="code"><code>const CancelToken = axios.CancelToken;
const source = CancelToken.source();

axios.get('https://api.example.com/data', { cancelToken: source.token })
  .catch(function (thrown) {
    if (axios.isCancel(thrown)) {
      console.log('Yêu cầu đã bị hủy:', thrown.message);
    } else {
      // Xử lý lỗi
    }
  });

// Hủy yêu cầu
source.cancel('Yêu cầu bị hủy bởi người dùng.');</code></pre><p id="93e3d6c1-db4e-4161-82e5-b084ce832e42" class=""><strong>Hỗ trợ tiến trình</strong>:</p><p id="80142ac4-3cf4-4f61-90a1-ddd868233d24" class=""><code><strong>axios</strong></code> cho phép bạn theo dõi tiến trình của yêu cầu.</p><pre id="c3db831e-dded-4274-8580-e5082b60b8d5" class="code"><code>const config = {
  onUploadProgress: progressEvent =&gt; console.log(`Đã tải lên: ${Math.round((progressEvent.loaded * 100) / progressEvent.total)}%`),
  onDownloadProgress: progressEvent =&gt; console.log(`Đã tải xuống: ${Math.round((progressEvent.loaded * 100) / progressEvent.total)}%`)
};

axios.get('https://api.example.com/large-file', config);</code></pre><p id="f33d9f3a-0a20-42da-92bc-868546c52aac" class=""><strong>Thêm header</strong>: </p><p id="7a92873f-c6b0-44ca-be27-0afb5b73b0d0" class="">Bạn dễ dàng thêm header vào yêu cầu sử dụng <code><strong>axios</strong></code>.</p><pre id="4500252b-a8e4-4ce5-ad31-ffbaffad7507" class="code"><code>axios.get('https://api.example.com/data', {
  headers: {
    'Authorization': 'Bearer your_token_here'
  }
});</code></pre><h3 id="b4f0ebf7-2288-4007-aae4-22a8a11beebc" class="block-color-yellow_background">10<strong>.  CORS, CSRF</strong></h3><ol type="1" id="9d436de4-c8fd-4631-b0f7-0a5c778cd10c" class="numbered-list" start="1"><li><strong>CORS (Chia sẻ nguồn lực qua các nguồn gốc khác nhau):</strong><ul id="f5c7100a-dfdf-419b-a08a-551a726e7aef" class="bulleted-list"><li style="list-style-type:disc"><strong>Là gì?</strong> Một quy định bảo mật trình duyệt không cho phép một trang web ở tên miền này gọi dữ liệu từ tên miền khác trừ khi tên miền kia cho phép.</li></ul><ul id="d4d1cc80-6f9c-437a-b269-6a0938d55728" class="bulleted-list"><li style="list-style-type:disc"><strong>Ví dụ React</strong>: Khi bạn sử dụng <code><strong>fetch</strong></code> hoặc <code><strong>axios</strong></code> để gọi API từ một server ở tên miền khác, bạn có thể gặp phải lỗi CORS.</li></ul></li></ol><ol type="1" id="f359b7c2-18c3-48fc-bf52-d35652199910" class="numbered-list" start="2"><li><strong>CSRF (Giả mạo yêu cầu trang web):</strong><ul id="4949a86e-cc3b-462b-9a98-ef4d8e18bef8" class="bulleted-list"><li style="list-style-type:disc"><strong>Là gì?</strong> Khi một kẻ xấu lừa bạn gửi một yêu cầu đến một trang web mà bạn đã đăng nhập mà không biết, làm thay đổi thông tin của bạn.</li></ul><ul id="439bbde6-c6bb-4d94-9ed6-4139ac2bbc8a" class="bulleted-list"><li style="list-style-type:disc"><strong>Ví dụ React</strong>: Khi bạn gửi dữ liệu qua form, bạn nên sử dụng một mã token CSRF để đảm bảo rằng yêu cầu đến server là hợp lệ.</li></ul></li></ol><p id="1b893805-4014-4e69-9ad1-c922eb546609" class=""><strong>Xử lý CORS</strong>:</p><p id="181dd4e9-c069-4238-85aa-6ec9cc725aa2" class="">Đảm bảo máy chủ API của bạn đặt tiêu đề phù hợp. Ví dụ, nếu bạn sử dụng Node.js và Express, bạn có thể sử dụng middleware như <code><strong>cors</strong></code>:</p><pre id="239dcf6e-904e-4776-84c4-dc479d4bb9b3" class="code"><code>const cors = require('cors');
app.use(cors());</code></pre><p id="863c2b5d-a88f-40b1-99ce-588aa5feb70f" class="">Trong React khi gọi api </p><pre id="19873f1f-aef7-430d-a10a-2f9221c830d0" class="code"><code>fetch('https://api.example.com/data')
  .then(response =&gt; response.json())
  .then(data =&gt; console.log(data))
  .catch(error =&gt; console.error('Có lỗi xảy ra:', error));</code></pre><p id="b5cc245e-fb3f-4f9e-8e14-115462e7539c" class=""><strong>Xử lý CSRF</strong>:</p><p id="5041cffa-3293-4234-ba0a-a89e443fe851" class="">Giả sử máy chủ đã gửi mã token CSRF cho bạn và bạn lưu trữ nó trong state của React:</p><pre id="fe562054-0871-49f6-8042-14b09b07a80a" class="code"><code>class App extends React.Component {
  state = {
    csrfToken: '',
  };

  componentDidMount() {
    // Giả sử bạn lấy token từ API và lưu vào state
    this.setState({ csrfToken: 'YOUR_CSRF_TOKEN_FROM_SERVER' });
  }

  handleSubmit = () =&gt; {
    fetch('https://api.example.com/submit-data', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-TOKEN': this.state.csrfToken,
      },
      body: JSON.stringify({ data: 'your data here' }),
    });
  }

  render() {
    return (
      &lt;button onClick={this.handleSubmit}&gt;Gửi dữ liệu&lt;/button&gt;
    );
  }
}</code></pre><p id="eb7ff041-3305-4615-b434-dcbbbd3c5af6" class="">chúng ta sử dụng tiêu đề <code><strong>X-CSRF-TOKEN</strong></code> để gửi token CSRF cùng với yêu cầu POST. Máy chủ sẽ kiểm tra token này trước khi xử lý dữ liệu.</p></div></article></body></html>